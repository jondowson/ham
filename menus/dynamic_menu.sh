#!/usr/local/bin/bash

# script_name: dynamic_menu.sh
# author: jd
# about: dynamically creates bash menu scripts
# notes: all dynamically created menus are generated by this script

function dynamic_menus() {

# incoming variables
# ${1} name of dynamic menu | ${2} parent menu

# rename incoming variables
DMENU="${1}"
PMENU="${2}"

# the instance(s) table
file_read=${TABLES}instances.txt

# delete any existing dynamically generated file for this menu
rm -f ${MENUS}dmenu_${DMENU}.sh

# the dynamic menu file to write to
file_write=${MENUS}dmenu_${DMENU}.sh

# determine if script is using public or private ips - set in ham_config.sh
if [ ${MODE} = "server" ]; then
    ip_type="prvIp"
else
    ip_type="pubIp"
fi

# variable strings that need to be written as variable strings into dynamically generated files
a_string="$"
b_string="MENU_NAME@"
c_string="option"
menu_string=${a_string}${b_string}
option_string=${a_string}${c_string}

# BOILERPLATE-1 --------------------------------------------------------------------------------------------

echo "#!/usr/local/bin/bash" >> ${file_write}
echo "" >> ${file_write}
echo "# script_name: dmenu_$DMENU.sh" >> ${file_write}
echo "# author: jd" >> ${file_write}
echo "# about: dynamically created by dynamic_menu.sh" >> ${file_write}
echo "" >> ${file_write}
echo "function dmenu_${DMENU}(){" >> ${file_write}
echo "banner" >> ${file_write}

# add a legend to dynamic menus
echo "echo \" ${white}#) HAM-app --- ${blue}Server Application ${white}--- Server Name --- ${blue}Server IP${reset}\"" >> ${file_write}
echo "echo \"\"" >> ${file_write}

echo "MENU_NAME=\"dmenu_${DMENU}\"" >> ${file_write}
echo "FIRST=\"first\"" >> ${file_write}
echo "MIDDLE=\"middle\"" >> ${file_write}
echo "PS3='...pick an option [Ctrl-c] to exit: '" >> ${file_write}
echo "select option in \\" >> ${file_write}

# MENU-OPTIONS --------------------------------------------------------------------------------------------

# this section deals with the menu options as seen by the user
# an entry is req'd here for each of the HAM menu applications that require dynamic refreshing
# non dynamic menu options are added to the static menu.sh script
# if extending HAM's functionality with dynamic menus - entries go here with corresponding entry in MENU-CALLS section
# dynamic menus are called from menus_refresh.sh

# loop through all the rows in the 'instances.txt' file
while IFS=$'\t' read name client cluster creator application pubIp prvIp key vpc state region size instance_id; do

    # check to see if name of server on amazon contains a space
    pattern=" "
    if [[ ${name} =~ ${pattern} ]]; then
        # replace space with an underscore
        name=${name// /_}
    fi

    # check that each server to be included in menu is not actually terminated
    # TODO worth check for other non running states - rebooting, pending, shutting-down or stopping ?
    if [ ${state} != "terminated" ]; then

#****** HAM-APP-1: start application(s) for a given server
        if [ ${DMENU} = "start_specific" ]; then

            # Server State: 'stopped' - first awaken on instance id before starting application(s)
            if [ ${state} = "stopped" ]; then
                echo "\"${white}${DMENU}---${blue}${application}${white}---${name}---${blue}${instance_id}${white}\" \\" >> ${file_write}

            # Server State: 'running' - start application(s) on ip address
            elif [ ${state} = "running" ]; then
                echo "\"${white}${DMENU}---${blue}${application}${white}---${name}---${blue}$(eval echo \$$ip_type)${white}\" \\" >> ${file_write}
            fi

#****** HAM-APP-2: connect into the cqlsh shell for those server(s) running Cassandra
        elif [ ${DMENU} = "connect_cqlsh" ]; then

             # Server State: 'running' - connect to cqlsh shell
             if [ ${state} = "running" ]; then
                if [ ${application} = "cassandra" ] || [ ${application} = "spark" ] || \
                   [ ${application} = "solr" ] || [ ${application} = "dse" ]; then
                    echo "\"${white}${DMENU}---${blue}${application}${white}---${name}---${blue}$(eval echo \$$ip_type)${white}\" \\" >> ${file_write}
                fi
             fi

#****** HAM-APP-3: connect to a server using ssh
        elif [ ${DMENU} = "connect_ssh" ]; then

            # Server State: 'running' - connect to ssh shell
            if [ ${state} = "running" ]; then
                 echo "\"${white}${DMENU}---${blue}${application}${white}---${name}---${blue}$(eval echo \$$ip_type)${white}\" \\" >> ${file_write}
            fi

#****** HAM-APP-4: stop the application(s) running on a server
        elif [ ${DMENU} = "stop_app" ]; then

            # Server State: 'running' - send stop command for application(s)
            if [ ${state} = "running" ]; then
                 echo "\"${white}${DMENU}---${blue}${application}${white}---${name}---${blue}$(eval echo \$$ip_type)${white}\" \\" >> ${file_write}
            fi

#****** HAM-APP-5: stop the application(s) running on a server + put server in a stopped state
        elif [ ${DMENU} = "stop_app_instance" ]; then

            # Server State: 'running' - send stop command for application(s) and instance
            if [ ${state} = "running" ]; then
                 echo "\"${white}${DMENU}---${blue}${application}${white}---${name}---${blue}$(eval echo \$$ip_type)${white}\" \\" >> ${file_write}
            fi

        fi
    fi
done < ${file_read}

# BOILERPLATE-2 --------------------------------------------------------------------------------------------

echo "\"back-up-a-menu-level\"" >> ${file_write}
echo "do" >> ${file_write}
echo "    case ${option_string} in" >> ${file_write}

# MENU-CALLS -----------------------------------------------------------------------------------------------

# this section writes the behind-the-scenes calls to be run when the user selects a menu option.
# a corresponding entry is required here for each of the HAM-APPs in the above MENU-OPTIONS section

# loop through all the rows in the 'instances.txt' file
while IFS=$'\t' read name client cluster creator application pubIp prvIp key vpc state region size instance_id; do

    # check to see if name of server on amazon contains a space
    pattern=" "
    if [[ $name =~ $pattern ]]; then
        # replace pattern with an underscore
        name=${name// /_}
    fi

    # ignore servers that have been terminated.
    # could also check for other non running states - rebooting, pending, shutting-down or stopping ?
    if [ ${state} != "terminated" ]; then

#****** HAM-APP-1: start application(s) for a given server
        if [ ${DMENU} = "start_specific" ]; then

            # Server State: 'stopped' - first awaken on instance id before starting application(s)
            if [ ${state} = "stopped" ]; then
                echo "        ${DMENU}---${application}---${name}---${instance_id})" >> ${file_write}
                echo "            ${DMENU} ${menu_string} ${application} ${key} ${instance_id};;" >> ${file_write}

            # Server State: 'running' - start application(s) on ip address
            elif [ ${state} = "running" ]; then
                echo "        ${DMENU}---${application}---${name}---$(eval echo \$$ip_type))" >> ${file_write}
                echo "            ${DMENU} ${menu_string} ${application} ${key} $(eval echo \$$ip_type);;" >> ${file_write}
            fi

#****** HAM-APP-2: connect into the cqlsh shell for those server(s) running Cassandra
        elif [ ${DMENU} = "connect_cqlsh" ]; then

            # Server State: 'running' - connect to cqlsh shell
            if [ ${state} = "running" ]; then
                if [ ${application} = "cassandra" ] || [ ${application} = "spark" ] || \
                   [ ${application} = "solr" ] || [ ${application} = "dse" ]; then
                    echo "        ${DMENU}---${application}---${name}---$(eval echo \$$ip_type))" >> ${file_write}
                    echo "            ${DMENU} ${key} $(eval echo \$$ip_type);;" >> ${file_write}
                fi
            fi

#****** HAM-APP-3: connect to a server using ssh
        elif [ ${DMENU} = "connect_ssh" ]; then

            # Server State: 'running' - connect to ssh shell
            if [ ${state} = "running" ]; then
                echo "        ${white}${DMENU}---${blue}${application}${white}---${name}---${blue}$(eval echo \$$ip_type)${white})" >> ${file_write}
                echo "            ${DMENU} ${key} $(eval echo \$$ip_type);;" >> ${file_write}
            fi

#****** HAM-APP-4: stop the application(s) running on a server
        elif [ ${DMENU} = "stop_app" ]; then

            # Server State: 'running' - send stop command for application(s)
            if [ ${state} = "running" ]; then
                echo "        ${white}${DMENU}---${blue}${application}${white}---${name}---${blue}$(eval echo \$$ip_type)${white})" >> ${file_write}
                echo "            ${DMENU} ${menu_string} ${application} ${key} $(eval echo \$$ip_type) false;;" >> ${file_write}
            fi

#****** HAM-APP-5: stop the application(s) running on a server + put server in a stopped state
        elif [ ${DMENU} = "stop_app_instance" ]; then

            # Server State: 'running' - send stop command for application(s)
            if [ ${state} = "running" ]; then
                echo "        ${white}${DMENU}---${blue}${application}${white}---${name}---${blue}$(eval echo \$$ip_type)${white})" >> ${file_write}
                echo "            ${DMENU} ${menu_string} ${application} ${key} $(eval echo \$$ip_type) true;;" >> ${file_write}
            fi

        fi
    fi
done < ${file_read}

# BOILERPLATE-3 --------------------------------------------------------------------------------------------

echo "        back-up-a-menu-level)" >> ${file_write}
echo "            ${PMENU};;" >> ${file_write}
echo "    esac" >> ${file_write}
echo "    break" >> ${file_write}
echo "done" >> ${file_write}
echo "}" >> ${file_write}

}
